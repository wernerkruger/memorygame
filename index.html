<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Number Memory Game</title>
<link rel="stylesheet" href="styles.css">

<!-- Firebase setup -->
<script type="module" src="firebase.js"></script>

<style>
/* ----- Add these styles for click feedback ----- */
.cell.userClick {
    background-color: #4CAF50; /* green */
    color: white;
    transition: background-color 0.3s;
}

.cell.userClickLast {
    background-color: #2196F3; /* blue */
    color: white;
    transition: background-color 0.3s;
}
</style>

</head>
<body>

<div id="topButtons">
    <span class="topBtn" id="toggleSound">Sound: ON</span>
    <span class="topBtn" id="toggleTheme">Theme: Dark</span>
</div>
<br>
<hr>

<div id="layout">

    <!-- LEFT: RANDOM HIGH SCORES -->
    <div id="leftBoard">
        <h2>Random Mode</h2>
        <h3>Top 10</h3>
        <table id="randomTable"></table>
    </div>

    <!-- CENTER: GAME -->
    <div id="gameContainer">
        <h1>Number Memory Game</h1>
        <div id="scores">
            Current Streak: <span id="currentStreak">0</span><br>
            Mode: <span id="modeLabel">Random</span><br>
            Progress: <span id="progress">- / -</span>
        </div>
        <div id="grid"></div>
        <div style="margin-top: 10px;">
            <label for="playerName">Your Name:</label>
            <input type="text" id="playerName" placeholder="Enter your name" style="width:150px; margin-right: 20px;">    
            <label for="piStart">Start PI from digit:</label>
            <input type="number" id="piStart" min="0" max="1000" value="0" style="width:60px">    
        </div>
        
        <div id="message">Press Random or PI</div>
        <div id="userSequence" style="margin-top: 10px; font-size: 1.2em; min-height: 1.5em; color: var(--text);"></div>
    </div>

    <!-- RIGHT: PI HIGH SCORES -->
    <div id="rightBoard">
        <h2>PI Mode</h2>
        <h3>Top 10</h3>
        <table id="piTable"></table>
    </div>

</div>

<script type="module">
/* ---------------------------------------------------
   OFFLINE/LOCAL STORAGE HIGH SCORE FUNCTIONS
--------------------------------------------------- */
function getLocalScores(mode) {
    const key = mode === "pi" ? "highscores_pi_local" : "highscores_random_local";
    const stored = localStorage.getItem(key);
    return stored ? JSON.parse(stored) : [];
}

function getDisplayScores(mode) {
    const key = mode === "pi" ? "highscores_pi_display" : "highscores_random_display";
    const stored = localStorage.getItem(key);
    return stored ? JSON.parse(stored) : null; // null means use local scores
}

function setDisplayScores(mode, scores) {
    const key = mode === "pi" ? "highscores_pi_display" : "highscores_random_display";
    if (scores && scores.length > 0) {
        localStorage.setItem(key, JSON.stringify(scores));
    } else {
        localStorage.removeItem(key);
    }
}

function saveLocalScore(name, score, mode) {
    const key = mode === "pi" ? "highscores_pi_local" : "highscores_random_local";
    const scores = getLocalScores(mode);
    scores.push({ name, score, timestamp: Date.now() });
    scores.sort((a, b) => b.score - a.score);
    // Keep more than top 10 locally so we can sync them later
    localStorage.setItem(key, JSON.stringify(scores));
    return scores;
}

function removeLocalScore(name, score, mode) {
    const key = mode === "pi" ? "highscores_pi_local" : "highscores_random_local";
    const scores = getLocalScores(mode);
    const filtered = scores.filter(s => !(s.name === name && s.score === score));
    localStorage.setItem(key, JSON.stringify(filtered));
    return filtered;
}

function isOnline() {
    return navigator.onLine && window.firebaseAvailable === true && window.db !== null && window.db !== undefined;
}

/* ---------------------------------------------------
   LOCAL-ONLY HIGH SCORE FUNCTIONS
--------------------------------------------------- */

// Use display scores if available (from sync), otherwise use local scores
function fetchScores(mode) {
    const displayScores = getDisplayScores(mode);
    if (displayScores !== null) {
        // Use cached display scores (merged Firebase + local from last sync)
        return displayScores.slice(0, 10);
    }
    // Otherwise use local scores only
    const localScores = getLocalScores(mode);
    return localScores.slice(0, 10);
}

async function submitScore(score, mode) {
    const nameInput = document.getElementById("playerName");
    let playerName = nameInput ? nameInput.value.trim() : "";
    
    // If name field is empty or user wants to change it
    if (!playerName) {
        playerName = prompt("You made the top 10! Enter your name:") || "Anonymous";
    } else {
        // Confirm the name from the field
        const confirmed = confirm(`You made the top 10! Add "${playerName}" to the leaderboard?`);
        if (!confirmed) {
            // User wants to change the name
            const newName = prompt("Enter your name:", playerName);
            if (newName !== null) {
                playerName = newName.trim() || "Anonymous";
            } else {
                // User cancelled, don't submit score
                return;
            }
        }
    }
    
    // Update the name field with the final name
    if (nameInput) {
        nameInput.value = playerName;
    }
    
    // Save locally
    saveLocalScore(playerName, score, mode);
    loadAndRenderTables();
    
    // Auto-sync after submitting score
    await syncHighScores();
}

/* ---------------------------------------------------
   MANUAL SYNC FUNCTION
--------------------------------------------------- */

async function syncHighScores() {
    try {
        const firestoreTools = window.firestoreTools;
        const db = window.db;
        
        if (!navigator.onLine) {
            console.log("Cannot sync: You are offline.");
            return;
        }
        
        if (!db || !window.firebaseAvailable || !firestoreTools) {
            console.log("Cannot sync: Firebase is not available.");
            return;
        }
        
        const { collection, getDocs, addDoc, query, orderBy } = firestoreTools;
        
        // Sync both modes
        for (const mode of ["random", "pi"]) {
            const modeName = mode === "pi" ? "PI" : "Random";
            
            // 1. Fetch existing Firebase scores
            let firebaseScores = [];
            try {
                const col = collection(db, mode === "pi" ? "highscores_pi" : "highscores_random");
                const q = query(col, orderBy("score", "desc"));
                const snap = await getDocs(q);
                firebaseScores = snap.docs.map(d => d.data());
                console.log(`Fetched ${firebaseScores.length} existing scores from Firebase for ${modeName} mode`);
            } catch (error) {
                console.warn(`Failed to fetch Firebase scores for ${modeName} mode:`, error);
            }
            
            // 2. Get local scores
            const localScores = getLocalScores(mode);
            console.log(`Found ${localScores.length} local scores for ${modeName} mode`);
            
            // 3. Upload local scores that don't exist in Firebase
            let uploadedCount = 0;
            const scoresToRemove = [];
            
            for (const localScore of localScores) {
                // Check if this score already exists in Firebase (same name and score)
                const exists = firebaseScores.some(
                    fs => fs.name === localScore.name && fs.score === localScore.score
                );
                
                if (!exists) {
                    try {
                        const col = collection(db, mode === "pi" ? "highscores_pi" : "highscores_random");
                        await addDoc(col, { name: localScore.name, score: localScore.score });
                        console.log(`Uploaded ${localScore.name}: ${localScore.score} to Firebase (${modeName})`);
                        uploadedCount++;
                        scoresToRemove.push(localScore);
                    } catch (error) {
                        console.warn(`Failed to upload score ${localScore.name}: ${localScore.score} (${modeName}):`, error);
                    }
                }
            }
            
            // 4. Remove successfully uploaded scores from local storage
            for (const scoreToRemove of scoresToRemove) {
                removeLocalScore(scoreToRemove.name, scoreToRemove.score, mode);
            }
            
            if (uploadedCount > 0) {
                console.log(`Synced ${uploadedCount} scores for ${modeName} mode`);
            }
            
            // 5. Fetch updated Firebase scores and merge with remaining local scores
            try {
                const col = collection(db, mode === "pi" ? "highscores_pi" : "highscores_random");
                const q = query(col, orderBy("score", "desc"));
                const snap = await getDocs(q);
                const updatedFirebaseScores = snap.docs.map(d => d.data());
                
                // Merge with remaining local scores (those that failed to upload or weren't uploaded)
                const remainingLocalScores = getLocalScores(mode);
                const allScores = [...updatedFirebaseScores, ...remainingLocalScores];
                
                // Remove duplicates and sort
                const uniqueScores = [];
                const seen = new Set();
                allScores.sort((a, b) => b.score - a.score);
                for (const score of allScores) {
                    const key = `${score.name}_${score.score}`;
                    if (!seen.has(key)) {
                        seen.add(key);
                        uniqueScores.push(score);
                    }
                }
                
                // Store merged scores for display (top 10)
                const mergedTop10 = uniqueScores.slice(0, 10);
                setDisplayScores(mode, mergedTop10);
                
                // Update local storage - only keep truly local scores (not in Firebase)
                const key = mode === "pi" ? "highscores_pi_local" : "highscores_random_local";
                const currentLocal = getLocalScores(mode);
                const trulyLocal = currentLocal.filter(localScore => {
                    return !updatedFirebaseScores.some(
                        fs => fs.name === localScore.name && fs.score === localScore.score
                    );
                });
                localStorage.setItem(key, JSON.stringify(trulyLocal));
            } catch (error) {
                console.warn(`Failed to refresh scores for ${modeName} mode:`, error);
            }
        }
        
        // Reload tables to show updated scores
        loadAndRenderTables();
        console.log("Sync completed successfully");
        
    } catch (error) {
        console.error("Error during sync:", error);
        // Don't show alert for background syncs, just log
    }
}

function renderTable(id, list) {
    const t = document.getElementById(id);
    if (list.length === 0) {
        t.innerHTML = "<tr><td colspan='2'>No scores yet</td></tr>";
        return;
    }
    t.innerHTML = "<tr><th>Name</th><th>Score</th></tr>" +
        list.map(x => `<tr><td>${x.name}</td><td>${x.score}</td></tr>`).join("");
}

function loadAndRenderTables() {
    try {
        const rand = fetchScores("random");
        const pi = fetchScores("pi");
        console.log("Loading scores - Random:", rand.length, "PI:", pi.length);
        renderTable("randomTable", rand);
        renderTable("piTable", pi);
    } catch (error) {
        console.error("Error loading scores:", error);
        // Render empty tables on error
        renderTable("randomTable", []);
        renderTable("piTable", []);
    }
}

// Load local scores immediately (no Firebase dependency)
loadAndRenderTables();

// Auto-sync on page load (non-blocking)
setTimeout(() => {
    syncHighScores().catch(err => console.log("Background sync failed:", err));
}, 1000);

/* ---------------------------------------------------
   SOUND + THEME
--------------------------------------------------- */
let soundEnabled = JSON.parse(localStorage.getItem("soundEnabled") ?? "true");
let theme = localStorage.getItem("theme") || "dark";
document.body.classList.toggle("light", theme === "light");

document.getElementById("toggleTheme").textContent =
    theme === "light" ? "Theme: Light" : "Theme: Dark";

document.getElementById("toggleSound").textContent =
    soundEnabled ? "Sound: ON" : "Sound: OFF";

document.getElementById("toggleTheme").onclick = () => {
    theme = theme === "dark" ? "light" : "dark";
    localStorage.setItem("theme", theme);
    document.body.classList.toggle("light", theme === "light");
    document.getElementById("toggleTheme").textContent =
        theme === "light" ? "Theme: Light" : "Theme: Dark";
};

document.getElementById("toggleSound").onclick = () => {
    soundEnabled = !soundEnabled;
    localStorage.setItem("soundEnabled", soundEnabled);
    document.getElementById("toggleSound").textContent =
        soundEnabled ? "Sound: ON" : "Sound: OFF";
};

// Create a single AudioContext and reuse it (much more efficient)
let audioContext = null;
function getAudioContext() {
    if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
    }
    // Resume context if it's suspended (browser autoplay policy)
    if (audioContext.state === 'suspended') {
        audioContext.resume();
    }
    return audioContext;
}

function playBeepForDigit(d) {
    if (!soundEnabled) return;
    const ctx = getAudioContext();
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();

    osc.frequency.value = 300 + d * 80;
    osc.connect(gain);
    gain.connect(ctx.destination);

    osc.start();
    gain.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + 0.35);
    osc.stop(ctx.currentTime + 0.35);
}

/* ---------------------------------------------------
   GAME LOGIC
--------------------------------------------------- */
const grid = document.getElementById("grid");
const message = document.getElementById("message");
const modeLabel = document.getElementById("modeLabel");
const currentStreakEl = document.getElementById("currentStreak");
const progressEl = document.getElementById("progress");
const userSequenceEl = document.getElementById("userSequence");

let sequence = [];
let userIndex = 0;
let userInputSequence = [];
let acceptingInput = false;
let currentStreak = 0;
let piMode = false;
let correctThisSession = 0;
let lastCorrectDigit = null; // Track the last correctly entered digit for replay

function updateProgress() {
    if (sequence.length === 0 || !acceptingInput) {
        progressEl.textContent = "- / -";
    } else {
        progressEl.textContent = `${userIndex} / ${sequence.length}`;
    }
}

function updateUserSequence() {
    if (userInputSequence.length === 0 || !acceptingInput) {
        userSequenceEl.textContent = "";
        userSequenceEl.style.whiteSpace = "normal"; // Reset to normal
    } else {
        userSequenceEl.textContent = userInputSequence.join(" ");
        userSequenceEl.style.whiteSpace = "normal"; // Reset to normal
    }
}

const PI_DIGITS = "31415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819";  

// Build grid 0-9
[...Array(10).keys()].forEach(n => {
    const c = document.createElement("div");
    c.className = "cell";
    c.textContent = n;
    c.dataset.value = n;
    grid.appendChild(c);
});

// Control buttons
function addButton(id, label) {
    const b = document.createElement("div");
    b.className = "cell";
    b.id = id;
    b.textContent = label;
    grid.appendChild(b);
}
addButton("start", "Rnd");
addButton("piModeButton", "PI");
addButton("reset", "Reset");
addButton("replayLast", "Replay Last");


const allCells = document.querySelectorAll(".cell");
// Create a lookup map for O(1) cell access instead of O(n) search
const cellMap = new Map();
allCells.forEach(cell => {
    const value = cell.dataset.value;
    if (value !== undefined) {
        cellMap.set(Number(value), cell);
    }
});

function flashCell(cell) {
    return new Promise(res => {
        cell.classList.add("flash");
        playBeepForDigit(Number(cell.dataset.value));
        setTimeout(() => {
            cell.classList.remove("flash");
            setTimeout(res, 150);
        }, 450);
    });
}

async function playSequence() {
    acceptingInput = false;
    userIndex = 0;
    userInputSequence = [];
    updateProgress();
    updateUserSequence();
    try {
        for (let d of sequence) {
            const cell = cellMap.get(d);
            if (cell) {
                await flashCell(cell);
            }
        }
    } catch (error) {
        console.error("Error playing sequence:", error);
    } finally {
        // Always set acceptingInput to true, even if there was an error
        acceptingInput = true;
        message.textContent = "Repeat the sequence!";
        updateProgress();
        updateUserSequence();
    }
}

function addDigit() {
    let next = piMode
        ? Number(PI_DIGITS[sequence.length])
        : Math.floor(Math.random() * 10);

    sequence.push(next);
    currentStreak = sequence.length;
    currentStreakEl.textContent = currentStreak;

    playSequence();
}

function startGame(random = true) {
    piMode = !random;
    modeLabel.textContent = piMode ? "PI" : "Random";

    sequence = [];
    userIndex = 0;
    userInputSequence = [];
    currentStreak = 0;
    currentStreakEl.textContent = 0;
    correctThisSession = 0;
    lastCorrectDigit = null;
    updateProgress();
    updateUserSequence();

    if (piMode) {
        const nInput = document.getElementById("piStart");
        let N = parseInt(nInput.value) || 0;
        if (N < 0) N = 0;
        if (N > PI_DIGITS.length) N = PI_DIGITS.length;

        for (let i = 0; i < N; i++) {
            sequence.push(Number(PI_DIGITS[i]));
        }
        currentStreak = N;
        currentStreakEl.textContent = currentStreak;

        message.textContent = `PI Mode starting from digit ${N + 1}`;
    } else {
        message.textContent = "Random Mode";
    }

    addDigit();
}

function resetGame() {
    sequence = [];
    userIndex = 0;
    userInputSequence = [];
    currentStreak = 0;
    currentStreakEl.textContent = 0;
    correctThisSession = 0;
    lastCorrectDigit = null;
    acceptingInput = false;
    message.textContent = "Game reset.";
    updateProgress();
    updateUserSequence();
}

async function replayLastDigit() {
    // Replay the very last digit of the entire sequence (the solution)
    if (sequence.length === 0) {
        message.textContent = "No digit to replay. Start a game first.";
        setTimeout(() => {
            if (acceptingInput) {
                message.textContent = "Repeat the sequence!";
            }
        }, 2000);
        return;
    }
    
    // Get the last digit of the entire sequence
    const lastDigit = sequence[sequence.length - 1];
    const cell = cellMap.get(lastDigit);
    
    if (cell) {
        // Temporarily disable input acceptance during replay to prevent interference
        const wasAccepting = acceptingInput;
        acceptingInput = false;
        await flashCell(cell);
        acceptingInput = wasAccepting;
    }
}

// ------------------- SHARED INPUT HANDLER -------------------
async function handleDigitInput(digit, cellElement = null) {
    if (!acceptingInput || digit === null || digit === undefined) return;
    
    // Safety check: ensure sequence is valid and userIndex is within bounds
    if (sequence.length === 0 || userIndex < 0 || userIndex >= sequence.length) {
        console.warn("Invalid state: sequence empty or userIndex out of bounds", { sequence, userIndex });
        return;
    }

    playBeepForDigit(digit);

    if (digit === sequence[userIndex]) {
        // Add to user input sequence
        userInputSequence.push(digit);
        lastCorrectDigit = digit; // Track the last correct digit for replay
        updateUserSequence();
        
        // Determine if this is the last digit in the sequence
        const isLast = userIndex === sequence.length - 1;
        
        // Highlight the cell if clicked (not keyboard input)
        if (cellElement) {
            cellElement.classList.add(isLast ? "userClickLast" : "userClick");
            setTimeout(() => cellElement.classList.remove(isLast ? "userClickLast" : "userClick"), 400);
        } else {
            // For keyboard input, highlight the corresponding cell visually
            const cell = cellMap.get(digit);
            if (cell) {
                cell.classList.add(isLast ? "userClickLast" : "userClick");
                setTimeout(() => cell.classList.remove(isLast ? "userClickLast" : "userClick"), 400);
            }
        }

        userIndex++;
        updateProgress();
        
        if (userIndex === sequence.length) {
            correctThisSession++; // Completed one sequence in this session
            userIndex = 0;
            userInputSequence = [];
            message.textContent = "Correct!";
            updateProgress();
            updateUserSequence();
            setTimeout(addDigit, 700);
        }
    } else {
        acceptingInput = false;
        
        // Show feedback with last 5 digits: last 4 correct + the wrong digit they just typed
        const last4CorrectUserDigits = userInputSequence.slice(-4);
        const wrongDigit = digit; // The wrong digit they just typed
        const last5UserDigits = [...last4CorrectUserDigits, wrongDigit];
        
        // Last 5 correct digits: last 4 they typed correctly + the correct digit they should have typed
        // Ensure userIndex is valid and sequence has the expected digit
        const last4CorrectSequenceDigits = sequence.slice(Math.max(0, userIndex - 4), userIndex);
        const correctDigit = (userIndex >= 0 && userIndex < sequence.length) ? sequence[userIndex] : undefined;
        const last5CorrectDigits = correctDigit !== undefined ? [...last4CorrectSequenceDigits, correctDigit] : last4CorrectSequenceDigits;
        
        let feedbackText = "";
        if (last5UserDigits.length > 0) {
            feedbackText = `Wrong: ... ${last5UserDigits.join(" ")}`;
        }
        if (last5CorrectDigits.length > 0) {
            feedbackText += feedbackText ? `\nRight: ..... ${last5CorrectDigits.join(" ")}` : `Right: ..... ${last5CorrectDigits.join(" ")}`;
        }
        
        if (correctThisSession > 0) {
            message.textContent = `Wrong! Final streak: ${currentStreak}`;
            if (feedbackText) {
                userSequenceEl.textContent = feedbackText;
                userSequenceEl.style.whiteSpace = "pre-line"; // Allow line breaks
            }
            await submitScore(currentStreak, piMode ? "pi" : "random");
        } else {
            message.textContent = "Wrong! No digits correctly played this session.";
            if (feedbackText) {
                userSequenceEl.textContent = feedbackText;
                userSequenceEl.style.whiteSpace = "pre-line"; // Allow line breaks
            }
        }
        updateProgress();
        
        // Delay reset to show feedback
        setTimeout(() => {
            resetGame();
        }, 12000);
    }
}

// ------------------- CLICK HANDLER -------------------
grid.addEventListener("click", (e) => {
    const cell = e.target;
    // Skip if it's a control button (they have their own handlers)
    if (cell.id === "start" || cell.id === "piModeButton" || cell.id === "reset" || cell.id === "replayLast") {
        return;
    }
    const val = cell.dataset.value;
    if (!val || !acceptingInput) return;
    handleDigitInput(Number(val), cell);
});

// ------------------- KEYBOARD HANDLER -------------------
document.addEventListener("keydown", (e) => {
    // Only handle number keys (0-9) when accepting input
    if (!acceptingInput) return;
    
    const key = e.key;
    // Check if it's a number key (0-9) on the main keyboard or numpad
    if (key >= "0" && key <= "9") {
        e.preventDefault(); // Prevent default behavior
        handleDigitInput(Number(key));
    }
});

// Control buttons
document.getElementById("start").onclick = () => startGame(true);
document.getElementById("piModeButton").onclick = () => startGame(false);
document.getElementById("reset").onclick = () => resetGame();
const replayBtn = document.getElementById("replayLast");
if (replayBtn) {
    replayBtn.onclick = async () => {
        await replayLastDigit();
    };
} else {
    console.error("Replay button not found!");
}

</script>

</body>
</html>
